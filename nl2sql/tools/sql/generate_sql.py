from __future__ import annotations

from typing import Dict

from google.adk.tools.agent_tool import AgentTool
from google.adk.tools.tool_context import ToolContext

from ...agents.sql_generator_agent import sql_generator_agent
from ...config import load_config
from ...utils.sql_dialect import get_sql_dialect_rules, normalize_db_type
from .sql_utils import _coerce_text, _normalize_sql


_SQL_GENERATOR_TOOL = AgentTool(sql_generator_agent)


async def generate_sql(
    question: str,
    table: str,
    tool_context: ToolContext,
    refinement: str | None = None,
) -> Dict[str, object]:
    """Call SQLGeneratorAgent and wrap its SQL output as JSON."""
    config = load_config()
    db_type = normalize_db_type(config.db_type)
    dialect_rules = get_sql_dialect_rules(db_type)
    if not table:
        tool_context.state["last_error"] = "Missing table for SQL generation."
        return {"success": False, "message": "Missing table for SQL generation."}

    table_schemas = tool_context.state.get("table_schemas") or {}
    columns = table_schemas.get(table)
    if not columns and table_schemas:
        lower_map = {name.lower(): name for name in table_schemas}
        match = lower_map.get(table.lower())
        if match:
            table = match
            columns = table_schemas[match]
    if not columns:
        tool_context.state["last_error"] = "Missing columns for SQL generation."
        return {"success": False, "message": "Missing columns for SQL generation."}

    prompt_parts = [
        f"User question: {_coerce_text(question).strip()}",
        f"Refinement: {_coerce_text(refinement).strip()}",
        f"Target table: {table}",
        "Columns:",
        "\n".join([f"- {col['name']} ({col.get('type', '')})" for col in columns]),
        f"Database type: {db_type}",
        "Dialect rules:",
        f"{dialect_rules}",
    ]
    prompt = "\n".join(prompt_parts) + "\n"
    try:
        sql_text = await _SQL_GENERATOR_TOOL.run_async(
            args={"request": prompt},
            tool_context=tool_context,
        )
    except Exception as exc:
        tool_context.state["last_error"] = str(exc)
        return {"success": False, "message": "SQL generator failed."}

    sql_text = _normalize_sql(sql_text)
    if not sql_text:
        tool_context.state["last_error"] = "Empty SQL from generator."
        return {"success": False, "message": "Empty SQL from generator."}

    tool_context.state["generated_sql"] = sql_text
    return {"success": True, "sql": sql_text, "reason": "generated by sql_generator_agent"}
