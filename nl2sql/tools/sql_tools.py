from __future__ import annotations

import json
import re
from typing import Dict

import sqlparse
from google.adk.tools.agent_tool import AgentTool
from google.adk.tools.tool_context import ToolContext

from ..agents.sql_generator_agent import sql_generator_agent
from ..config import load_config
from ..database import get_mysql_connection
from ..utils.sql_dialect import get_sql_dialect_rules, normalize_db_type


DANGEROUS_SQL_PATTERNS = [
    r"\bDELETE\b",
    r"\bINSERT\b",
    r"\bUPDATE\b",
    r"\bDROP\b",
    r"\bTRUNCATE\b",
    r"\bALTER\b",
    r"\bCREATE\b",
    r"\bGRANT\b",
    r"\bREVOKE\b",
    r"\bEXEC\b",
    r"\bEXECUTE\b",
    r"\bCALL\b",
    r"\bRENAME\b",
    r"\bREPLACE\b",
    r"\bMERGE\b",
    r"\bLOAD\b",
    r"\bINTO\s+OUTFILE\b",
    r"\bINTO\s+DUMPFILE\b",
]


def validate_sql_is_readonly(sql: str) -> bool:
    """
    Args:
        sql: The SQL statement to validate

    Returns:
        True if SQL is safe (read-only), False otherwise
    """
    if not sql or not sql.strip():
        return False

    cleaned = _strip_sql_comments(sql).strip()
    if not cleaned:
        return False

    for pattern in DANGEROUS_SQL_PATTERNS:
        if re.search(pattern, cleaned, re.IGNORECASE):
            return False

    statements = _split_sql_statements(cleaned)
    if not statements:
        return False
    for stmt in statements:
        stmt_upper = stmt.strip().upper()
        if not re.match(r"^(SELECT|WITH|SHOW|DESCRIBE|DESC|EXPLAIN)\b", stmt_upper):
            return False

    return True


def _normalize_sql(sql: str) -> str:
    cleaned = sql.strip().strip("`").strip()
    if cleaned.startswith("```"):
        cleaned = cleaned.strip("`").strip()
    return cleaned


def _coerce_text(value: object) -> str:
    if value is None:
        return ""
    if isinstance(value, str):
        return value
    if isinstance(value, (dict, list)):
        return json.dumps(value, ensure_ascii=True)
    return str(value)


def _split_sql_statements(sql: str) -> list[str]:
    return [stmt.strip() for stmt in sqlparse.split(sql) if stmt.strip()]


def _strip_sql_comments(sql: str) -> str:
    return sqlparse.format(sql, strip_comments=True)


_SQL_GENERATOR_TOOL = AgentTool(sql_generator_agent)


async def generate_sql(
    question: str,
    table: str,
    tool_context: ToolContext,
    refinement: str | None = None,
) -> Dict[str, object]:
    """Call SQLGeneratorAgent and wrap its SQL output as JSON."""
    config = load_config()
    db_type = normalize_db_type(config.db_type)
    dialect_rules = get_sql_dialect_rules(db_type)
    if not table:
        tool_context.state["last_error"] = "Missing table for SQL generation."
        return {"success": False, "message": "Missing table for SQL generation."}

    table_schemas = tool_context.state.get("table_schemas") or {}
    columns = table_schemas.get(table)
    if not columns and table_schemas:
        lower_map = {name.lower(): name for name in table_schemas}
        match = lower_map.get(table.lower())
        if match:
            table = match
            columns = table_schemas[match]
    if not columns:
        tool_context.state["last_error"] = "Missing columns for SQL generation."
        return {"success": False, "message": "Missing columns for SQL generation."}

    prompt_parts = [
        f"User question: {_coerce_text(question).strip()}",
        f"Refinement: {_coerce_text(refinement).strip()}",
        f"Target table: {table}",
        "Columns:",
        "\n".join([f"- {col['name']} ({col.get('type', '')})" for col in columns]),
        f"Database type: {db_type}",
        "Dialect rules:",
        f"{dialect_rules}",
    ]
    prompt = "\n".join(prompt_parts) + "\n"
    try:
        sql_text = await _SQL_GENERATOR_TOOL.run_async(
            args={"request": prompt},
            tool_context=tool_context,
        )
    except Exception as exc:
        tool_context.state["last_error"] = str(exc)
        return {"success": False, "message": "SQL generator failed."}

    sql_text = _normalize_sql(sql_text)
    if not sql_text:
        tool_context.state["last_error"] = "Empty SQL from generator."
        return {"success": False, "message": "Empty SQL from generator."}

    tool_context.state["generated_sql"] = sql_text
    return {"success": True, "sql": sql_text, "reason": "generated by sql_generator_agent"}


def run_sql(query: str, tool_context: ToolContext) -> Dict[str, object]:
    """Execute SQL after validating it is read-only."""
    sql = _normalize_sql(query)

    if not validate_sql_is_readonly(sql):
        tool_context.state["last_error"] = "Only read-only SQL queries are allowed."
        return {"status": "error", "error_message": "Only read-only SQL queries are allowed."}

    try:
        connection = get_mysql_connection()
        cursor = connection.cursor()
        result_sets = []
        statements = _split_sql_statements(sql)
        if not statements:
            tool_context.state["last_error"] = "Empty SQL after parsing."
            return {"status": "error", "error_message": "Empty SQL after parsing."}
        for statement in statements:
            cursor.execute(statement)
            with_rows = getattr(cursor, "with_rows", False)
            if with_rows or cursor.description:
                rows_data = cursor.fetchall()
                columns = [desc[0] for desc in cursor.description] if cursor.description else []
                rows = [list(row) for row in rows_data]
                result_sets.append(
                    {
                        "sql": statement,
                        "columns": columns,
                        "rows": rows,
                        "row_count": len(rows),
                    }
                )
            else:
                row_count = cursor.rowcount if cursor.rowcount is not None else 0
                result_sets.append(
                    {
                        "sql": statement,
                        "columns": [],
                        "rows": [],
                        "row_count": row_count,
                    }
                )
    except Exception as exc:
        tool_context.state["last_error"] = str(exc)
        return {"status": "error", "error_message": "MySQL query failed."}
    finally:
        if "cursor" in locals():
            cursor.close()

    if not result_sets:
        result_sets = [{"sql": sql, "columns": [], "rows": [], "row_count": 0}]

    primary = result_sets[0]
    payload = {
        "status": "success",
        "sql": sql,
        "columns": primary.get("columns", []),
        "rows": primary.get("rows", []),
        "row_count": primary.get("row_count", 0),
        "result_sets": result_sets,
    }
    tool_context.state["generated_sql"] = sql
    tool_context.state["sql_result"] = payload
    tool_context.state["last_error"] = None
    tool_context.state["sql_run_success"] = True
    return payload
