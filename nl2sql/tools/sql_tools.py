from __future__ import annotations

import re
from typing import Dict

from google.adk.tools.agent_tool import AgentTool
from google.adk.tools.tool_context import ToolContext

from ..agents.sql_generator_agent import sql_generator_agent
from ..config import load_config
from ..database import get_mysql_connection
from ..utils.sql_dialect import get_sql_dialect_rules, normalize_db_type


DANGEROUS_SQL_PATTERNS = [
    r"\bDELETE\b",
    r"\bINSERT\b",
    r"\bUPDATE\b",
    r"\bDROP\b",
    r"\bTRUNCATE\b",
    r"\bALTER\b",
    r"\bCREATE\b",
    r"\bGRANT\b",
    r"\bREVOKE\b",
    r"\bEXEC\b",
    r"\bEXECUTE\b",
    r"\bCALL\b",
    r"\bRENAME\b",
    r"\bREPLACE\b",
    r"\bMERGE\b",
    r"\bLOAD\b",
    r"\bINTO\s+OUTFILE\b",
    r"\bINTO\s+DUMPFILE\b",
]


def validate_sql_is_readonly(sql: str) -> bool:
    """
    Args:
        sql: The SQL statement to validate

    Returns:
        True if SQL is safe (read-only), False otherwise
    """
    if not sql or not sql.strip():
        return False

    sql_upper = sql.upper().strip()

    # Remove comments that might be used to hide malicious code
    # Remove single-line comments (-- and #)
    sql_upper = re.sub(r"--.*$", "", sql_upper, flags=re.MULTILINE)
    sql_upper = re.sub(r"#.*$", "", sql_upper, flags=re.MULTILINE)
    sql_upper = re.sub(r"/\*.*?\*/", "", sql_upper, flags=re.DOTALL)
    sql_upper = sql_upper.strip()

    if not re.match(r"^(SELECT|WITH|SHOW|DESCRIBE|DESC|EXPLAIN)\b", sql_upper):
        return False

    for pattern in DANGEROUS_SQL_PATTERNS:
        if re.search(pattern, sql_upper, re.IGNORECASE):
            return False

    # Check for multiple statements (semicolon followed by another statement)
    # This prevents SQL injection like: SELECT * FROM x; DELETE FROM y
    statements = [s.strip() for s in sql_upper.split(";") if s.strip()]
    if len(statements) > 1:
        for stmt in statements[1:]:
            if stmt and not re.match(
                r"^(SELECT|WITH|SHOW|DESCRIBE|DESC|EXPLAIN)\b", stmt
            ):
                return False

    return True


def _normalize_sql(sql: str) -> str:
    cleaned = sql.strip().strip("`").strip()
    if cleaned.startswith("```"):
        cleaned = cleaned.strip("`").strip()
    return cleaned


_SQL_GENERATOR_TOOL = AgentTool(sql_generator_agent)


async def generate_sql(
    question: str,
    table: str,
    tool_context: ToolContext,
) -> Dict[str, object]:
    """Call SQLGeneratorAgent and wrap its SQL output as JSON."""
    config = load_config()
    db_type = normalize_db_type(config.db_type)
    dialect_rules = get_sql_dialect_rules(db_type)
    if not table:
        tool_context.state["last_error"] = "Missing table for SQL generation."
        return {"success": False, "message": "Missing table for SQL generation."}

    table_schemas = tool_context.state.get("table_schemas") or {}
    columns = table_schemas.get(table)
    if not columns and table_schemas:
        lower_map = {name.lower(): name for name in table_schemas}
        match = lower_map.get(table.lower())
        if match:
            table = match
            columns = table_schemas[match]
    if not columns:
        tool_context.state["last_error"] = "Missing columns for SQL generation."
        return {"success": False, "message": "Missing columns for SQL generation."}

    prompt = (
        f"User question: {question}\n"
        f"Target table: {table}\n"
        "Columns:\n"
        + "\n".join([f"- {col['name']} ({col.get('type', '')})" for col in columns])
        + f"\nDatabase type: {db_type}\n"
        "Dialect rules:\n"
        f"{dialect_rules}\n"
    )
    try:
        sql_text = await _SQL_GENERATOR_TOOL.run_async(
            args={"request": prompt},
            tool_context=tool_context,
        )
    except Exception as exc:
        tool_context.state["last_error"] = str(exc)
        return {"success": False, "message": "SQL generator failed."}

    sql_text = _normalize_sql(sql_text)
    if not sql_text:
        tool_context.state["last_error"] = "Empty SQL from generator."
        return {"success": False, "message": "Empty SQL from generator."}

    tool_context.state["generated_sql"] = sql_text
    return {"success": True, "sql": sql_text, "reason": "generated by sql_generator_agent"}


def run_sql(query: str, tool_context: ToolContext) -> Dict[str, object]:
    """Execute SQL after validating it is read-only."""
    sql = _normalize_sql(query)

    if not validate_sql_is_readonly(sql):
        tool_context.state["last_error"] = "Only read-only SQL queries are allowed."
        return {"status": "error", "error_message": "Only read-only SQL queries are allowed."}

    try:
        connection = get_mysql_connection()
        cursor = connection.cursor()
        cursor.execute(sql)
        rows_data = cursor.fetchall()
        columns = [desc[0] for desc in cursor.description] if cursor.description else []
    except Exception as exc:
        tool_context.state["last_error"] = str(exc)
        return {"status": "error", "error_message": "MySQL query failed."}
    finally:
        if "cursor" in locals():
            cursor.close()

    rows = [list(row) for row in rows_data]

    payload = {
        "status": "success",
        "sql": sql,
        "columns": columns,
        "rows": rows,
        "row_count": len(rows),
    }
    tool_context.state["generated_sql"] = sql
    tool_context.state["sql_result"] = payload
    tool_context.state["last_error"] = None
    tool_context.state["sql_run_success"] = True
    return payload
